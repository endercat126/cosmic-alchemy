fun prop(name: String) = providers.gradleProperty(name).get()

val mod_id = prop("mod_id")

plugins {
    `java-library`
    idea
    `maven-publish`
    id("net.neoforged.moddev") version "2.0.134"
    id("org.jetbrains.kotlin.jvm") version "2.1.20"
    id("org.jetbrains.kotlin.plugin.serialization") version "2.1.20"
}

version = prop("mod_version")
group = prop("mod_group_id")

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}
kotlin {
    jvmToolchain(21)
}

repositories {
    mavenLocal()

    maven("https://thedarkcolour.github.io/KotlinForForge/") {
        name = "Kotlin for Forge"
        content {
            includeGroup("thedarkcolour")
        }
    }
    maven("https://api.modrinth.com/maven") {
        name = "Modrinth"
        content {
            includeGroup("maven.modrinth")
        }
    }
}

base {
    archivesName.set(mod_id)
}

neoForge {
    // Specify the version of NeoForge to use.
    version = prop("neo_version")

    parchment {
        mappingsVersion.set(prop("parchment_mappings_version"))
        minecraftVersion.set(prop("parchment_minecraft_version"))
    }

    mods {
        // define mod <-> source bindings
        // these are used to tell the game which sources are for which mod
        // mostly optional in a single mod project
        // but multi mod projects should define one per mod
        create(mod_id) {
            sourceSet(sourceSets.main.get())
        }
    }

    // Default run configurations.
    // These can be tweaked, removed, or duplicated as needed.
    runs {
        create("client").apply {
            client()
            systemProperty("neoforge.enabledGameTestNamespaces", mod_id)
        }

        create("server").apply {
            server()
            programArgument("--nogui")
            systemProperty("neoforge.enabledGameTestNamespaces", mod_id)
        }

        create("gameTestServer").apply {
            type = "gameTestServer"
            systemProperty("neoforge.enabledGameTestNamespaces", mod_id)
        }

        create("data").apply {
            data()
            loadedMods = listOf(mods[mod_id])
            programArguments.addAll(
                "--mod",
                mod_id,
                "--all",
                "--output",
                file("src/generated/resources/").absolutePath,
                "--existing",
                file("src/main/resources/").absolutePath
            )
        }

        // applies to all the run configs above
        configureEach {
            systemProperty("forge.logging.markers", "REGISTRIES")
            logLevel.set(org.slf4j.event.Level.INFO)
        }
    }
}

// Include resources generated by data generators.
sourceSets {
    main {
        resources {
            srcDir("src/generated/resources")
        }
    }
}

dependencies {
    implementation("thedarkcolour:kotlinforforge-neoforge:5.10.0")

    runtimeOnly("maven.modrinth:sodium:mc1.21.1-0.6.13-neoforge")
    runtimeOnly("maven.modrinth:iris:1.8.12+1.21.1-neoforge")
    runtimeOnly("maven.modrinth:jade:15.10.3+neoforge")
    runtimeOnly("maven.modrinth:emi:1.1.22+1.21.1+neoforge")
    runtimeOnly("maven.modrinth:ferrite-core:7.0.2-neoforge")
}

val generateModMetadata by tasks.registering(ProcessResources::class) {
    val replaceProperties = listOf(
        "minecraft_version",
        "minecraft_version_range",
        "neo_version",
        "neo_version_range",
        "loader_version_range",
        "mod_id",
        "mod_name",
        "mod_license",
        "mod_version",
        "mod_authors",
        "mod_description"
    ).associateWith { prop(it) }

    inputs.properties(replaceProperties)
    expand(replaceProperties)

    from("src/main/templates")
    into(layout.buildDirectory.dir("generated/sources/modMetadata"))
}

// Include the output of "generateModMetadata" as an input directory for the build
// this works with both building through Gradle and the IDE.
sourceSets.main {
    resources.srcDir(generateModMetadata)
}

// To avoid having to run "generateModMetadata" manually, make it run on every project reload
neoForge.ideSyncTask(generateModMetadata)

// Example configuration to allow publishing using the maven-publish plugin
publishing {
    publications {
        create<MavenPublication>("mavenJava") {
            from(components["java"])
        }
    }
    repositories {
        maven {
            url = uri("file://${project.projectDir}/repo")
        }
    }
}

// IDEA no longer automatically downloads sources/javadoc jars for dependencies, so we need to explicitly enable the behavior.
idea {
    module {
        isDownloadSources = true
        isDownloadJavadoc = true
    }
}
